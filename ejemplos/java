## [2016-02-22 09:30] Ejemplo 1

### Java

abstract class A {}
interface I1 {}
interface I2 {}
class B extends A implements I1 {}
class C extends B implements I2 {}
class D extends A implements I2 {}

class Main {
  static void main (String[] args) {

  }
}

### Compiled

A (JavaAbstractClass) {}
B (JavaClass) {
  @extends A
  @implements I1
}
C (JavaClass) {
  @extends B
  @implements I2
}
D (JavaClass) {
  @extends A
  @implements I2
}

@JavaClassExtends (Boolean) (JavaClass, JavaClass) {

}

## [2016-02-22 09:47] Ejemplo 2

### Java

abstract class Animal {
  abstract String hablar ();
}
class Perro extends Animal {
  @override
  String hablar () {println("Wurf!");}
}
class Gato extends Animal {
  @override
  String hablar () {println("Miau!");}
}
class Main {
  static void nombrar (Animal) { println("animal"); }
  static void nombrar (Gato)   { println("gato");   }
  static void nombrar (Perro)  { println("perro");  }
  static void main (String[] args) {
    Gato g = new Gato();
    Animal ag = new Gato();
    Perro p = new Perro();
    Animal ap = new Perro();
    ag.hablar();
    ap.hablar();
    nombrar(g);
    nombrar(ag);
  }
}

### Compiled Original

Animal (Class) {
  $supers [JavaObject]
  $vtable {}
}
Perro (Class) { $supers [Animal, JavaObject] }
Gato (Class) {
  $supers (Vtable) {
    $
  }
}

### Tipo Haskell

// En haskell, Los comentarios son con -- y no es 'trait', es 'class'
trait Animal a where
  hablar :: a -> IO String

data Perro
instance Animal Perro where
  hablar _ = print "Wurf!"

data Gato
instance Animal Gato where
  hablar _ = print "Miau!"

// Esto es imposible, porque la función es paramétrica
// Si se parametriza la función como nombrar<Perro>, usarla con un Gato no
// tiene sentido. Por esto esta opción no sirve
nombrar :: (Animal a) => a -> IO String
nombrar Perro = print "perro"
nombrar Gato = print "gato"
nombrar _ = print "animal"

// Esta es la única opción que queda...
nombrarGato :: Gato -> IO String
nombrarGato _ = print "gato"
nombrarPerro :: Perro -> IO String
nombrarPerro _ = print "gato"
nombrarAnimal :: (Animal a) => a -> IO String
nombrarAnimal _ = print "animal"

// En haskell no existe Downcasting, por eso 'nombra', cómo está
// en Java, es imposible

main = do
  g <- Gato
  p <- Perro
  ag <- g :: Animal
  ap <- p :: Animal
  hablar ag
  hablar ap
  hablarGato g
  hablarAnimal ag


### Compiled

Animal (AbstractClass) {
  vtable (AbstractVtable) {
    hablar Function<String>
  }
}
Perro (Class) {
  extends Animal
  Perro_Animal_vtable (Abstract_Animal_vtable) {
    hablar (Function<String><Perro>)
  }
}
Perro_Animal_hablar (Function) {

}
Perro_Animal_hablar_code (Code) {

}
Perro_Animal_vtable (AbstractVtable) {
  hablar Perro_Animal_hablar
}


## [2016-02-22 11:34] Super Simple

abstract class Animal {}
class Gato extends Animal {}
static void main () {
  Gato g = new Gato();
  Animal a = g;
}

### Compiled

@JavaClass {

}
Animal (JavaClass) {}
Gato (JavaClass) {
  extend Animal
}
GatoConstructor (JavaInstance) {
  class Gato
}
CoreIsSubtype <JavaInstance, JavaInstance> {

}
main (Function) {
  g:Gato = GatoConstructor()
  a:Animal = g
}

### Compiled Original

Animal (Class) {
  $supers [JavaObject]
}
Gato (Class) {
  $supers [JavaObject, Animal]
}
Gato_new (Constructor) {
  $class Gato
}
main (Function) {
  g:Gato = GatoConstructor()
  a:Animal = g
}

## [2016-02-22 13:05] Una Clase

class MyClass {}
static void main () {
  MyClass o = new MyClass();
}

### Compiled Primera Versión

MyClass (Class) {
  $supers [JavaObject]
}
MyClass_new (Constructor) {
  $class MyClass
}
main (Function) {
  o:MyClass = MyClass_new()
}
